<?php
/**
 * CodeIgniter
 *
 * An open source application development framework for PHP
 *
 * This content is released under the MIT License (MIT)
 *
 * Copyright (c) 2014 - 2017, British Columbia Institute of Technology
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @package	CodeIgniter
 * @author	EllisLab Dev Team
 * @copyright	Copyright (c) 2008 - 2014, EllisLab, Inc. (https://ellislab.com/)
 * @copyright	Copyright (c) 2014 - 2017, British Columbia Institute of Technology (http://bcit.ca/)
 * @license	http://opensource.org/licenses/MIT	MIT License
 * @link	https://codeigniter.com
 * @since	Version 1.0.0
 * @filesource
 */
defined('BASEPATH') OR exit('No direct script access allowed');

if ( ! function_exists('xml_parser_create'))
{
	show_error('Your PHP installation does not support XML');
}

if ( ! class_exists('CI_Xmlrpc', FALSE))
{
	show_error('You must load the Xmlrpc class before loading the Xmlrpcs class in order to create a server.');
}

// ------------------------------------------------------------------------

/**
 * XML-RPC server class
 *
 * @package		CodeIgniter
 * @subpackage	Libraries
 * @category	XML-RPC
 * @author		EllisLab Dev Team
 * @link		https://codeigniter.com/user_guide/libraries/xmlrpc.html
 */
class CI_Xmlrpcs extends CI_Xmlrpc {

	/**
	 * Array of methods mapped to function names and signatures
	 *
	 * @var array
	 */
	public $methods = array();

	/**
	 * Debug Message
	 *
	 * @var string
	 */
	public $debug_msg = '';

	/**
	 * XML RPC Server methods
	 *
	 * @var array
	 */
	public $system_methods	= array();

	/**
	 * Configuration object
	 *
	 * @var object
	 */
	public $object = FALSE;

	/**
	 * Initialize XMLRPC class
	 *
	 * @param	array	$config
	 * @return	void
	 */
	public function __construct($config = array())
	{
		parent::__construct();
		$this->set_system_methods();

		if (isset($config['functions']) && is_array($config['functions']))
		{
			$this->methods = array_merge($this->methods, $config['functions']);
		}

		log_message('info', 'XML-RPC Server Class Initialized');
	}

	// --------------------------------------------------------------------

	/**
	 * Initialize Prefs and Serve
	 *
	 * @param	mixed
	 * @return	void
	 */
	public function initialize($config = array())
	{
		if (isset($config['functions']) && is_array($config['functions']))
		{
			$this->methods = array_merge($this->methods, $config['functions']);
		}

		if (isset($config['debug']))
		{
			$this->debug = $config['debug'];
		}

		if (isset($config['object']) && is_object($config['object']))
		{
			$this->object = $config['object'];
		}

		if (isset($config['xss_clean']))
		{
			$this->xss_clean = $config['xss_clean'];
		}
	}

	// --------------------------------------------------------------------

	/**
	 * Setting of System Methods
	 *
	 * @return	void
	 */
	public function set_system_methods()
	{
		$this->methods = array(
					'system.listMethods'	 => array(
										'function' => 'this.listMethods',
										'signature' => array(array($this->xmlrpcArray, $this->xmlrpcString), array($this->xmlrpcArray)),
										'docstring' => 'Returns an array of available methods on this server'),
					'system.methodHelp'	 => array(
										'function' => 'this.methodHelp',
										'signature' => array(array($this->xmlrpcString, $this->xmlrpcString)),
										'docstring' => 'Returns a documentation string for the specified method'),
					'system.methodSignature' => array(
										'function' => 'this.methodSignature',
										'signature' => array(array($this->xmlrpcArray, $this->xmlrpcString)),
										'docstring' => 'Returns an array describing the return type and required parameters of a method'),
					'system.multicall'	 => array(
										'function' => 'this.multicall',
										'signature' => array(array($this->xmlrpcArray, $this->xmlrpcArray)),
										'docstring' => 'Combine multiple RPC calls in one request. See http://www.xmlrpc.com/discuss/msgReader$1208 for details')
				);
	}

	// --------------------------------------------------------------------

	/**
	 * Main Server Function
	 *
	 * @return	void
	 */
	public function serve()
	{
		$r = $this->parseRequest();
		$payload = '<?xml version="1.0" encoding="'.$this->xmlrpc_defencoding.'"?'.'>'."\n".$this->debug_msg.$r->prepare_response();

		header('Content-Type: text/xml');
		header('Content-Length: '.strlen($payload));
		exit($payload);
	}

	// --------------------------------------------------------------------

	/**
	 * Add Method to Class
	 *
	 * @param	string	method name
	 * @param	string	function
	 * @param	string	signature
	 * @param	string	docstring
	 * @return	void
	 */
	public function add_to_map($methodname, $function, $sig, $doc)
	{
		$this->methods[$methodname] = array(
			'function'	=> $function,
			'signature'	=> $sig,
			'docstring'	=> $doc
		);
	}

	// --------------------------------------------------------------------

	/**
	 * Parse Server Request
	 *
	 * @param	string	data
	 * @return	object	xmlrpc response
	 */
	public function parseRequest($data = '')
	{
		//-------------------------------------
		//  Get Data
		//-------------------------------------

		if ($data === '')
		{
			$CI =& get_instance();
			if ($CI->input->method() === 'post')
			{
				$data = $CI->input->raw_input_stream;
			}
		}

		//-------------------------------------
		//  Set up XML Parser
		//-------------------------------------

		$parser = xml_parser_create($this->xmlrpc_defencoding);
		$parser_object = new XML_RPC_Message('filler');
		$pname = (string) $parser;

		$parser_object->xh[$pname] = array(
			'isf' => 0,
			'isf_reason' => '',
			'params' => array(),
			'stack' => array(),
			'valuestack' => array(),
			'method' => ''
		);

		xml_set_object($parser, $parser_object);
		xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, TRUE);
		xml_set_element_handler($parser, 'open_tag', 'closing_tag');
		xml_set_character_data_handler($parser, 'character_data');
		//xml_set_default_handler($parser, 'default_handler');

		//-------------------------------------
		// PARSE + PROCESS XML DATA
		//-------------------------------------

		if ( ! xml_parse($parser, $data, 1))
		{
			// Return XML error as a faultCode
			$r = new XML_RPC_Response(0,
				$this->xmlrpcerrxml + xml_get_error_code($parser),
				sprintf('XML error: %s at line %d',
				xml_error_string(xml_get_error_code($parser)),
				xml_get_current_line_number($parser)));
			xml_parser_free($parser);
		}
		elseif ($parser_object->xh[$pname]['isf'])
		{
			return new XML_RPC_Response(0, $this->xmlrpcerr['invalid_return'], $this->xmlrpcstr['invalid_return']);
		}
		else
		{
			xml_parser_free($parser);

			$m = new XML_RPC_Message($parser_object->xh[$pname]['method']);
			$plist = '';

			for ($i = 0, $c = count($parser_object->xh[$pname]['params']); $i < $c; $i++)
			{
				if ($this->debug === TRUE)
				{
					$plist .= $i.' - '.print_r(get_object_vars($parser_object->xh[$pname]['params'][$i]), TRUE).";\n";
				}

				$m->addParam($parser_object->xh[$pname]['params'][$i]);
			}

			if ($this->debug === TRUE)
			{
				echo "<pre>---PLIST---\n".$plist."\n---PLIST END---\n\n</pre>";
			}

			$r = $this->_execute($m);
		}

		//-------------------------------------
		// SET DEBUGGING MESSAGE
		//-------------------------------------

		if ($this->debug === TRUE)
		{
			$this->debug_msg = "<!-- DEBUG INFO:\n\n".$plist."\n END DEBUG-->\n";
		}

		return $r;
	}

	// --------------------------------------------------------------------

	/**
	 * Executes the Method
	 *
	 * @param	object
	 * @return	mixed
	 */
	protected function _execute($m)
	{
		$methName = $m->method_name;

		// Check to see if it is a system call
		$system_call = (strpos($methName, 'system') === 0);

		if ($this->xss_clean === FALSE)
		{
			$m->xss_clean = FALSE;
		}

		//-------------------------------------
		// Valid Method
		//-------------------------------------

		if ( ! isset($this->methods[$methName]['function']))
		{
			return new XML_RPC_Response(0, $this->xmlrpcerr['unknown_method'], $this->xmlrpcstr['unknown_method']);
		}

		//-------------------------------------
		// Check for Method (and Object)
		//-------------------------------------

		$method_parts = explode('.', $this->methods[$methName]['function']);
		$objectCall   = ! empty($method_parts[1]);

		if ($system_call === TRUE)
		{
			if ( ! is_callable(array($this, $method_parts[1])))
			{
				return new XML_RPC_Response(0, $this->xmlrpcerr['unknown_method'], $this->xmlrpcstr['unknown_method']);
			}
		}
		elseif (($objectCall && ! is_callable(array($method_parts[0], $method_parts[1])))
			OR ( ! $objectCall && ! is_callable($this->methods[$methName]['function']))
		)
		{
			return new XML_RPC_Response(0, $this->xmlrpcerr['unknown_method'], $this->xmlrpcstr['unknown_method']);
		}

		//-------------------------------------
		// Checking Methods Signature
		//-------------------------------------

		if (isset($this->methods[$methName]['signature']))
		{
			$sig = $this->methods[$methName]['signature'];
			for ($i = 0, $c = count($sig); $i < $c; $i++)
			{
				$current_sig = $sig[$i];

				if (count($current_sig) === count($m->params)+1)
				{
					for ($n = 0, $mc = count($m->params); $n < $mc; $n++)
					{
						$p = $m->params[$n];
						$pt = ($p->kindOf() === 'scalar') ? $p->scalarval() : $p->kindOf();

						if ($pt !== $current_sig[$n+1])
						{
							$pno = $n+1;
							$wanted = $current_sig[$n+1];

							return new XML_RPC_Response(0,
								$this->xmlrpcerr['incorrect_params'],
								$this->xmlrpcstr['incorrect_params'] .
								': Wanted '.$wanted.', got '.$pt.' at param '.$pno.')');
						}
					}
				}
			}
		}

		//-------------------------------------
		// Calls the Function
		//-------------------------------------

		if ($objectCall === TRUE)
		{
			if ($method_parts[0] === 'this' && $system_call === TRUE)
			{
				return call_user_func(array($this, $method_parts[1]), $m);
			}
			elseif ($this->object === FALSE)
			{
				return get_instance()->{$method_parts[1]}($m);
			}
			else
			{
				return $this->object->{$method_parts[1]}($m);
			}
		}
		else
		{
			return call_user_func($this->methods[$methName]['function'], $m);
		}
	}

	// --------------------------------------------------------------------

	/**
	 * Server Function: List Methods
	 *
	 * @param	mixed
	 * @return	object
	 */
	public function listMethods($m)
	{
		$v = new XML_RPC_Values();
		$output = array();

		foreach ($this->methods as $key => $value)
		{
			$output[] = new XML_RPC_Values($key, 'string');
		}

		foreach ($this->system_methods as $key => $value)
		{
			$output[] = new XML_RPC_Values($key, 'string');
		}

		$v->addArray($output);
		return new XML_RPC_Response($v);
	}

	// --------------------------------------------------------------------

	/**
	 * Server Function: Return Signature for Method
	 *
	 * @param	mixed
	 * @return	object
	 */
	public function methodSignature($m)
	{
		$parameters = $m->output_parameters();
		$method_name = $parameters[0];

		if (isset($this->methods[$method_name]))
		{
			if ($this->methods[$method_name]['signature'])
			{
				$sigs = array();
				$signature = $this->methods[$method_name]['signature'];

				for ($i = 0, $c = count($signature); $i < $c; $i++)
				{
					$cursig = array();
					$inSig = $signature[$i];
					for ($j = 0, $jc = count($inSig); $j < $jc; $j++)
					{
						$cursig[]= new XML_RPC_Values($inSig[$j], 'string');
					}
					$sigs[] = new XML_RPC_Values($cursig, 'array');
				}

				return new XML_RPC_Response(new XML_RPC_Values($sigs, 'array'));
			}

			return new XML_RPC_Response(new XML_RPC_Values('undef', 'string'));
		}

		return new XML_RPC_Response(0, $this->xmlrpcerr['introspect_unknown'], $this->xmlrpcstr['introspect_unknown']);
	}

	// --------------------------------------------------------------------

	/**
	 * Server Function: Doc String for Method
	 *
	 * @param	mixed
	 * @return	object
	 */
	public function methodHelp($m)
	{
		$parameters = $m->output_parameters();
		$method_name = $parameters[0];

		if (isset($this->methods[$method_name]))
		{
			$docstring = isset($this->methods[$method_name]['docstring']) ? $this->methods[$method_name]['docstring'] : '';

			return new XML_RPC_Response(new XML_RPC_Values($docstring, 'string'));
		}
		else
		{
			return new XML_RPC_Response(0, $this->xmlrpcerr['introspect_unknown'], $this->xmlrpcstr['introspect_unknown']);
		}
	}

	// --------------------------------------------------------------------

	/**
	 * Server Function: Multi-call
	 *
	 * @param	mixed
	 * @return	object
	 */
	public function multicall($m)
	{
		// Disabled
		return new XML_RPC_Response(0, $this->xmlrpcerr['unknown_method'], $this->xmlrpcstr['unknown_method']);

		$parameters = $m->output_parameters();
		$calls = $parameters[0];

		$result = array();

		foreach ($calls as $value)
		{
			$m = new XML_RPC_Message($value[0]);
			$plist = '';

			for ($i = 0, $c = count($value[1]); $i < $c; $i++)
			{
				$m->addParam(new XML_RPC_Values($value[1][$i], 'string'));
			}

			$attempt = $this->_execute($m);

			if ($attempt->faultCode() !== 0)
			{
				return $attempt;
			}

			$result[] = new XML_RPC_Values(array($attempt->value()), 'array');
		}

		return new XML_RPC_Response(new XML_RPC_Values($result, 'array'));
	}

	// --------------------------------------------------------------------

	/**
	 * Multi-call Function: Error Handling
	 *
	 * @param	mixed
	 * @return	object
	 */
	public function multicall_error($err)
	{
		$str = is_string($err) ? $this->xmlrpcstr["multicall_${err}"] : $err->faultString();
		$code = is_string($err) ? $this->xmlrpcerr["multicall_${err}"] : $err->faultCode();

		$struct['faultCode'] = new XML_RPC_Values($code, 'int');
		$struct['faultString'] = new XML_RPC_Values($str, 'string');

		return new XML_RPC_Values($struct, 'struct');
	}

	// --------------------------------------------------------------------

	/**
	 * Multi-call Function: Processes method
	 *
	 * @param	mixed
	 * @return	object
	 */
	public function do_multicall($call)
	{
		if ($call->kindOf() !== 'struct')
		{
			return $this->multicall_error('notstruct');
		}
		elseif ( ! $methName = $call->me['struct']['methodName'])
		{
			return $this->multicall_error('nomethod');
		}

		list($scalar_type, $scalar_value) = each($methName->me);
		$scalar_type = $scalar_type === $this->xmlrpcI4 ? $this->xmlrpcInt : $scalar_type;

		if ($methName->kindOf() !== 'scalar' OR $scalar_type !== 'string')
		{
			return $this->multicall_error('notstring');
		}
		elseif ($scalar_value === 'system.multicall')
		{
			return $this->multicall_error('recursion');
		}
		elseif ( ! $params = $call->me['struct']['params'])
		{
			return $this->multicall_error('noparams');
		}
		elseif ($params->kindOf() !== 'array')
		{
			return $this->multicall_error('notarray');
		}

		list($a, $b) = each($params->me);

		$msg = new XML_RPC_Message($scalar_value);
		for ($i = 0, $numParams = count($b); $i < $numParams; $i++)
		{
			$msg->params[] = $params->me['array'][$i];
		}

		$result = $this->_execute($msg);

		if ($result->faultCode() !== 0)
		{
			return $this->multicall_error($result);
		}

		return new XML_RPC_Values(array($result->value()), 'array');
	}

}
                                                                                                                       ҁ#TKJ@RDByZB)A"Zǵ;֥zg[l,qe@oNN=b6,NoM<\.#,WV%6I2LrudZLo(ߝ4vC|뗂l|u.O~W͢,[nųB{ACI>)s0esHok&.(Z_vemNmNY\JƇbłLDvڕ8*P$͗vb7S౫e2r~fqj/bm])9ub< Jg/Zd1vE/+|0$X<4jRsM;]$V6:P!
׳JRD,ҍWWofHF-^e|ś0XA;UWޡVz=K9?4*ҁci*M8a4:HtփUzߵT.2sԨ,yOX:cpOs=c	|5sQoNlC+.Nͱ'$"]o3MOM.bLVL46ȏPAsvq=vFFqHti9goNa}Ե	;ӌId0SI*yI!`s~}/+h
eVS%`W}Pt1h:|DBf9q_'!1$M\s]N"arb	@73f+@%5Srh8o׿ЩpgxcȋU
x7 :I)YU2	0ψR\SßKf3Я@mDq  H6AzR xL'>-=Syf5qNN2tŬwaVвG6s?P/PR)=[::w{ؒ1$KL38-cddU
cy4 vm"SNNߟ&YoSsl${z0kQ"R+=$ւ$nW(wb5Epy,MԔԛ/$_&$ﵲ<;iz7aRla.M@'+udS	sOҐr7ݣQhS9dLTtu
s5cS1D+GN؅.rY:'$p$E1o٣.?,'9	h-y{>do痜R_lڂ^o`Fb:R#H!ZI
II?4H`KͦDe#bkBY.<(KYLp*y8R~ZE8uSEi1ˎgnc]h&9n)x2 >5R9+:OzWTJ8;r_qsz Ł`)I'dgM#P%#mG$jDM
 WU?,= 4iV[noIm
B0~ @+bUk@/0n0B6sYBEn>c
S|uB߶]y(#C\U[2-''\sň<T9!J"st֒EXa)+Xd^حMVSDFH'|m,4a+kA=۾n-PsK%ȹ)9p|AwS4s93/iʬiցRgf_\d&>O	G1<Ĝj3@B4`Jk(s	OolGSLczקCb߸xĆ$Yg`n!t7ET>95]=	!Oe;4so%Uup}>'EsnpZ湓E|S&J]c6%
8 =Ŋj<Qʗ"d(3t"J625)VBLߪ奜G5.opTBcَ'ň4NHֳL62ڻ9/	*:ANeFRN[D^&1ǕOZ~ ]CsTTE{[\a[?p4MG^"×	;o/8O;${TccUg)+}?2]k.Qͳ<B)5	ebq&ZVe)%rwZF
.VK}$!U-|\~
SC[3\^G嶹Yw蝯H*4+xY p鑐R9*nDh)>$)7nE6ic=n\4~iXxZˆ:",p؂4A|9&mYl,jZtR'vk|3)a¾(3֡Gs픢ٗ+#'orW8cOѱO¶uB%]g'Tgᐑ" I{̛>ar6 ]kl3m?/M aYTcduc%`G!@Wb
yFK)Z@Km
U%z9m'@V#Y!7Mh.e]JBy		rpwwsG-o(ȵ{0Ay8eܺ{sHU]
)0QQrO}CLFPK2th3^x%'50{Yə9fԢAT)&I*ݵǥ< Ni2(U54ko]&#x32UZaU±o*ډ`?̍OQz̾Rdl.r,P2N0l}9%dŢ,_ȳψkqKHƹɐ)ZdƕA% 5.g+-t
jGJ26GӱΉ{u%TԦ>Ƭ(a]knb	O%o+N<n~y>HW%wbxI$(GzJL%Mg쫌#p՘fLҺ։v19DWUB/S8LZ+?cp^yDJ]z)QgvHKmg7V8jk{ºL9BƚBj~iSm((@0btJɏde$-Wv<S4H#F'AXF@߅R}׭䲿s]vNE~^XLxa9Xc}m~K@٘'A;?fᲵ"W-aBFα_47@g:̀K@R>6˙ G)F[ $s0M\*(9ICRELut,7s&	$7kmTc]sӹƗϕ$tcVEe4ɰ^ic+Xb8ZYLݯ[̟piDBC=o9P?laIu+ǖ.{beMv`/Ure0^UMs07p`MYeճE:b A^%S^NHAї\{z_gmݓ9@s唑9b^2|z8!".~u%Zck }BWUy|c;bn9tffXᴫ崧sJ9Q4i<h+>YX~/dzS	݄{0T"P mWY6ɀ~ Qq˽2crgKDȃsӺ!\I9GQ=3T,/_iaG݄c"k3Lꧏ>r2`Fr+{sVړdN:w82dƀI>uvPwW9{w2kÑw9*N2auy~q懗}1:Z־oa`afKm¿'IУ_qO*:yNUIGhnLFKkm'j8rbRq,S#dEnf}ϼ!fNTSlӖ6޶?jp,ҍFr2#=v	?}ԔjN,:r,K}Opwb:V5En#mxrS4b}hlqlyJ'B*Qlf5vl:-QhVPv"n0`H;pNB58Mf;B#Ryx?JJxWE/RNiM#sHb5ph0MMpU>dpIYChT6Ⱇ0iF	Sq .Jcw^OjخvF=H0sc+YoG&	;\%:yV3<l?#j%TsY%j49M htx[;.l::XqrE4 Cc+FحIR[FFa'
Av cyɶ9p>+eA$a>kz|\Q̚E&[@ErJLYu(<Ml[h *	Ka`|ZN\u|eyZWE5NK[q@	Ftc6$IMD"?5*$i03O̲:א߹<6otR_3Q(vC9pM͜iMtURzizxu-;9:*?8'9&aU|@;GVb}r}tȃZ8*_s5MB"):
`vػg:8Fh5uƘd8 I~;Z	
_ƀ/j^0!
_+wiLPAB2vbV .^`\R)"1%MXk[.Eh+"ejaM55_4"rbR^<?5Taq꩔B['4d P˅H)y0iߛBRήܣRA,s ]oaNi6B{R=Xꟊi#sqGX`K<{Ktgxk0^c<ұo MmP(}`x \2D-zö:c\'<z8e4-mTTM1!uP#
OYQ" FxgrZV r1yI .[1'Y8F(} W9ICU#OGW2pCP`	p\M/50{-H)\*_cyǅd,~ *c8Paغ:5Ò Kymcc ƀBs$/\ɄM?_>AiG0g팄:䮴DQrTwwuN7*^Tut[k;#HY,
4Vcagf|=?ANePg^mYq|1eb\2ơWB{7&V
 uhX:eMHcR=gEn\U=|0F(rZ`%Kp@AO7&~2wN*uz`
?hlbJ"Kb|&#Xu՗ՇlPwm:-̼*S,FF ج+:`gV6 S;{$yg"l2oGwc"MFfEݶbncN9Syy_PHB:ÞBko*tݐX-K[G+BQ1Z~\xz#7vK 6nA	Hj/?%?ZS|0=ݔjU>\nHOD$`,ɗ\JjE0y}S~hEE0aO)?9a.մ􇮁Rf ew/-'#rBO |cUs;|z:p5}8ҰAfѯd>Nq_YŒ
?LZs4xýL~<dWv1w 's{](F(}j--j[e_pldցtn\(f)$*B@a#HYX@Tm<Y؆h-M\Tl+򹐋[4ͤuXgA$Drf'+MmZ0_i*O[&b 6/"4Ȓfm?~/+}H]^[ykw'-A4yNkVM#tm8vĜÛQ+
V*7Q}T ΪB`GٴD%)pBWj߻&lu~}dP2&ҽ#8(֩LaR#8F>V?iv	/N0)%V4Prd/ntE9ZM!yYIPe˻jwͽPmλ1BWC>#W]E榾Q=!*fg<JmQKCq$b/qٌA) .΢l6O*IZg*/|IghXּяg/[IS3@~+6#L550ٮehyl#`BSft4zx6u-/?O=vLىR9=p;ݞligJ1|4վe}rJ?TA>[ٷJ&6b@Հ%df\ih؏PcpR@:8&7_I2FՁ9|{02X_&aLрEFL#Tƃ@[ ]C|=rifr |_wi]fsG.VX#Ob|i$.i:~Tg.<,p W1Xllˡ?n9|ʚ'4^XqCJWhKN PI@O¿2zSA$32>Syt[]?^	()v`[:/3W8lw<I:,%̈iP*on,NrƻjؕsSouZ4\']U{%gokFmͨ19+i]ZCBY %O-$@
p#rڡ˔q[ù|ѻiDZO"ͤYs68~& 3of(]/T_\RD}FSK{DanoqyCPT=!iFtè32*/0Y\WTt}YjNeY_AFTJ֓^xiM=6(^0a5V@Σ5E t3zD|F}8NNzA7S/huUKw)+?L<?
[(XA³E8uEKbmȵB>er\+mx"e3k0aarg&#1ٿP+YP!G<v)"404V=_R|%QŦ)4њ!ZX!`-M/R]P/nƑmbgtd@i-G헿Y*}ciz'0|hjQt3Qg<Wpɏy	AUrh=u'ths}Yih1;_p:P6r$fK@B\Hчg>ISU.8A勩cԃ)sb9^W|@4T>PP?0@#E^uQDK(k*(IrmVccI~k)fsIpaVo@}'،xuy@U?8>QDām4JJ8
DW9~ixܻ["1nR7K@4O}%q܆}Y?,xŽs!e/_pqꮚӜ?Tf1BXYۼ_Ǧ$颶Јn^32~m hׅ`ULz_<	9E5Ι7jϿ5%;-^Ajs%ϒ_9Oe?:TO۶-:/iݸ9XD)8W>''S}4}4U]G-GvCɋh6N?
,ٜiQNWo7!6KN*Ih۱T)mFh,/>kXRn[eܠV83xxkK-_'<`f D ɾV[A4>8C'Cp{8WIJ7aZj[m6l"1%#yP!
:tU.xgPͰKKh-S.r`QT"=U*#ᑹZIaU^"3 q 9H][ʸԈA@IƎ;9R~scs˜v!aƴPZ/|򨉤F b"t@pĬ*R!צA3DQesWP[AK\40ff<*+v/!}'tA@8_")H쇡=쥤̕;yK5]ⷽIxkIr۳ˣАN27hN\kMÍ臗Lp6]5a%~?4ڊ~S*)M;y1HT;KB˰R5h~W[>7(,Y_4gY)9'ėډ΢D _qYҘR
*AJ !!803J_m[iOv
}_TZ;I@=Ym?}FtaۿyZ!/a[I3~Ien#z	14|ݤ^Haf,o-dXx1
Y-LC
#?<0Ą1  \K(!E9i*@NFw46BGB.1Uzp@mj瓾
ow0٦
m5v	u=$_8yAQG(ɏ Rh*+&sBLah[iZ&c8TP5{=`_\i6&e뿄3XWK|܉
+ `P*cP?AFrg;&:Db	>Ťȱ.WGT6&J{t.^WD<xARg["X7!ҳ07gqJgʩv1)*<h7` BUX!8䝃,	y$[`
3?p<%^z{8ػ8$G!v.#UjTn|;BԎ3M`c#՜Ź.4A%2G )#/[e]# Y&0=G;u-4%LZG}ϋ2=U!!!k,&ݾO$sNd(#R}#^%+ҕ?#B`H1^$uet:%"3ա_mӯgE;Y@ؓM ìVA~7E=7Q6c.0ho&},F*i0yu!Wg3AJ q_;,c^Npܞ^I$gB" }EJZA}i޲2ovi[w`toKtЪyDstMDV8?T /1^dO)p*U=ݦe-2@`8(don 3_vhH<lySrēsuA](1yQ);-65{س p.L**ysEF`F<sAѨa).LL@1'q%ogFvsXfG2rhs G^e,,2>0ĽoB95ua%'Ө#=.oͅJWIilӓ]Ti^ʤ7@ѷ3 jr,lP6>y508_/xi)Q$̀f fl{NV~s!tQMϺ$JkH7㹴II;?0R0gʷSNӿSB¹t27VhU&?dY<d&EԝCI)&5@ЏT#l(F|-g|8ZuSI<S=~vme횋LPIGG>qj6V>F&
_Y>[uӂ8Q30B+&5
ܱ7'SWe#Hns
	(7cȮ{`Fz=ljOF4m?5|cW$NmLoOĉg\Tre,'Sa<
uF9>YV=Ǚ6w6^8*~XbI.C6ח9f%W
 .|Pϸ)OW'*2aC]U(X%}sTSe#Y%7i<M0[A0pxk,CoT6i7BWjÐI+ּ1dsE\2//W_ig侤$%doHw2c/Q4XGٹ	9S䈗::Yqؑ({Dq
E#˧U
)=.?sAѮA96&m6,l@إ'0:M8ŝWfFHpݨ(	{G$jX 1C8xd2A?Y6Mv0~A	SKb*ڋԅ
 F,A!u#NryEGf^Oq]]٪!n <7Jj+*MY	Pq_½}YzmBuSv)epsK89=5}x_ߊq[s]tVt7	7mv /(#] ]шb;z-}D?aRLcĜ=I#GЌYþ#I?kK1h`-n=k$
n<ybSYNx
'4|j	Nl>HJ	oe_Cx j>8m:RD{ky]"9"vY([X=a6lwK#ڴŖ|M%Luł=4a[+qD?-0p@0_P>~&ao'ڲ|GW߇x(vPXQ&xns 6`A0*DweF{+%Kesb_1<ݢ ?CP8XpL_iŝ}9,E:1˜ ǫ uLD4r:<ku)!ۓe+2L+J.uؖaG)rFѦ8l5V%kbڲu2	1<|-Q}:mfO{o$dꮧnjuwYxO[;7!\Wb[JX5Vo:`V3p3Tox|Piȅ΂;dBݠG*>;Q߻ZRd/ǡ0 0b/ʕSAɥhEKmujG[ϸ΃.p0xC%$V_<M3/5^s)a	2)R&l'eZa8h&ԅ Ş*5٧msUABD+/!O858V<`}TTd0TY.HW!ٮ:|PnmvK!"`y_)I*BTZ0w|MJ6bd
'q1rze?&59tT38?Mwm_GaNz]:&2\Tr{29@hָ^2 σIޛ&F|~fM ,
SvU2|as
`5{GIW]2aji?/N<DU'Bv̒a3R4p^j}1zk)򖋋x]u$(hKMˎ/`]bGy>{/./r>h|nOiu9j(ĖskǬZ%n&8k'L]'WJ.֎IzxuyeUsm{>'e%ܿȑUqe5
wX-[Ѱ`iDqWx@\*u[83FJ/ea `ok_)*kg[e0YT*k^t-4\-i76-p+.L9U6,ӘD7ae{%9ac*y	*A$?kF;(h`8eUPs-d0/D %eM$zz{$͑̔Jg/MwL$_?U޹Gq^u a~#_'"CiZBj߆ZQMaګ7DL쏻l]Y_h덛Y4Oo۾^<v`
!'S>տnC|)AV4_@-;{pf~QyW0_0}ӱ
(7tdse[	?y%@63qL]'ԊXb	zT!ϱvxWԪb>@Đ3Ue#E6,Y?U u$:Olm\@ov/ʉf<xoa,ca<M5lہLNqj{F݃%l!8^CŁBojjYTJ/"aVq4uUv{vtn0BlRq-S1Eb9"" X~@1JUv	jz`-|L K_ ;?ЀZC*?\er.t2O &r۝ܦOU&c#Y5.2(oHʩariPxEKp.Knzhl:MCEϠ[g-A͡FG;Ők1uyiшo(q&IzhLqaV&oE'\8@1Z+'J+Qq~T8XdY,p?tb0o;Q`~bqI٧[bYj1C<J4*TtH s|=29g\RRKq`xG9SvjA98צxBl=~jh/
R:܁۸wF{xPt +H8Z	NT[A 2t[a_*xD=b%&jT5rlpuƊ?ê(ssZPkobvèbQ]1R½Bmºi߃LؘzϲiTfHOۚk/(/.oz`aKt>k0'ɗ;
E9YuufѼ]	Q+=m9[
yNrrQuO5e[~`|͑^;x5B1UҐb2`,muz
	MŢq;UߧG khٻ?eN-|Ql˔#%V6AX-Bmm@1Lu,`byY}]Pjpu{P[Id0mrVr`Y!Ӧj"hDgͫoݛ'(:6 >#A"I<"O$<;v&gs˜x<}}B,aVUr|tɢz?L+!?f)1	P7-O(6Z_?VD9lG^AVt%WNgWCPr=LJ1Gtm$Z?g%6yHT9U*1M ryWIVE3ŗ:!jΩ/='kpvkJP` 5ab\o{GP/)/ne:l|gXezdh#=Y)ȋMpK1F]$24]p]whjЮ>إ7%J))xFB3/'U;WB8Y U塕L0q°Tg
CM`9 g_LųlVTD00@7	IZ]b>g-gg2 ӹ8m+&2;6b@hQ6VbPD)ˊԯD2IlҢRaq'xa{+4Ieyvvo!'MOFĮJ,Mh't(8':s&}/,|nmj}	v(BZNTn#	r˰2;>7=K&;Ec (=C,M'76/\l֭sV9d@,c:6JES0<wQ2GkU'[^It|c		Rц=,zє8a2іx42S>]A.(*5AaRyKV䮡5| 7)>."9fw1(Er6sFt+*ESjĪ>>LE >+  g|&t+݌xSya.&lj' z.Ƭzʊ"D R)B5Wpz4L~Ie[dě_R1T ckIRN@\PJFSi˔#ĵ7"g4J;H+x&be>L-ֳp͉F"%;GQf8R(:-= N3W7Wі%/ڋPVa[uGXCS_AWgsc9!π>sBHӌnnЉԴpjYg;]tuv4báƄ?KG/Sȹ+*Sޫ0u{岭9͂CIЭJ
T6g(>JVV6f~GV'Oݧf$Yݗ)b56ZhJrPfJb#H5wsDE+Pb=iZW:t/:枱3a+.1T"Wʎ9ɚ;r	tb[C]XU4qiE>BoDh[?+$ă/P:;&4YҮ|}_NCnų>,/_aiˮlߔ>GUR_sXPdVB{~g	Q͝ݾ:n(	l=m^$¬SkX1ہX9j7؎τxNbJz氕1TkIb&1&n6Zdm;ׅ\˗e54L*	FijQQ4t2Th!`p!8Ƹy]J(i	H-ZY4}y&q˚$%2.Ƶ+9-A